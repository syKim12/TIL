프로세스: 프로그램을 메모리 상에서 실행중인 작업
스레드: 프로세스 안에서 실행되는 여러 흐름 단위, 스레드는 stack만 할당 받고 나머지 영역은 공유한다.

기본적으로 프로세스마다 최소 1개의 스레드 소유
프로세스는 자신만의 고유공간과 자원을 할당받지만 스레드는 다른 스레드와 자원을 공유한다

멀티 프로세스 장점: 메모리 침범 문제를 os 차원에서 해결하기 때문에 안정성이 좋다
멀티 프로세스 단점: 각각 독립된 메모리 영역을 갖고 있기 때문에 작업량 많을수록 오버헤드가 발생하며, context switching으로 성능이 저하된다.

멀티스레드 장점: 다른 스레드와 자원을 공유하기 때문에 자료 공유 가능, 자원 손실 감소
멀티스레드 단점: 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드에서 망가지기 때문에 안정성이 낮다.

프로세스가 생성되면 PCB에 Process의 메타데이터가 저장된다.
PCB 필요한 이유: 인터럽트 등의 이벤트가 발생하였을 때 다시 수행할 대기중인 프로세스에 관한 저장값을 PCB에 저장해둔다.
PCB: Process state, Process counter, CPU Register, CPU scheduling information, Memory management information, Account information, I/O status information


Context Switching: 수행 중인 프로세스를 변경하여 CPU의 레지스터 정보가 변경되는 것, 보통 인터럽트 등이 발생할 때 일어난다.


IPC 통신: 프로세스는 독립적으로 실행되기 때문에 프로세스간 통신을 가능케 해주는 것
프로세스는 커널이 제공하는 IPC 설비로 프로세스 간 통신을 할 수 있다.

IPC 종류:
- 공유 메모리: 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 함, IPC 중 가장 빠름
- 메모리 맵: 열린 파일을 메모리에 맵핑시켜서 공유하는 방식. 즉 공유 매개체는 메모리와 파일이다. 주로 파일로 대용량 데이터를 공유하라때 사용한다.
- 익명 파이프
- Named 파이프: 익명이 아니기 때문에 부모프로세스에서 자식프로세스 뿐만 아니라 다른 프로세스도 통신 가능

IPC 통신에서 프로세스 간 데이터를 보호하기 위해 세마포어와 뮤텍스를 사용

세마포어: 공유 자원에 여러 프로세스가 접근하면 문제가 발생할 수 있기 때문에 공유 자원에 대한 접근을 제한하는 방법
- 임계구역이 있으며 한 프로세스가 임계 구역을 수행할 때 다른 프로세스가 접근하지 못하도록 해야한다.
뮤텍스: 임계구역을 가진 스레드의 실행시간이 겹치지 않고 단독으로 실행되게 함, 접근을 조율하기 위해 lock, unlock 사용
- lock: 임계 구역에 들어갈 권한을 얻어옴
- unlock: 임계구역을 모두 사용했음을 알림
세마포어에서 카운터를 하나 쓴다면 뮤텍스와 동일하다

CPU 스케쥴링: CPU를 잘 사용하기 위해 프로세스를 잘 배정하는 것.
- 선점 스케쥴링: OS가 CPU의 사용권을 선점할 수 있는 경우 (처리시간 예측 어려움)
- 비선점 스케쥴링: 프로세스 종료 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 용이)


데드락: 프로세스에서 서로 원하는 자원이 상대방에게 할당되어있어 두 프로세스가 무한정으로 wait하는 상태
발생조건
- 상호 배제: 자원은 한번에 한 프로세스만 사용할 수 있음
- 점유 대기: 다른 프로세스에 할당되어 사용하고 있는 자원을 점유하기 위해서는 대기하는 프로세스 존재
- 비선점: 다른 프로세스에 할당된 자원을 강제로 빼앗을 수 없음
- 순환 대기: 프로세스의 집합에서 순환형태로 자원을 대기하고 있어야함

데드락 예방: 교착상태의 발생조건 중 하나를 제거하며 해결 <- 자원낭비 심함
데드락 회피: 교착상태 발생 시 피해나가는 방법
- 은행원 알고리즘: 시스템에서 자원을 프로세스에할당한 후에도 안정한지 사전에 확인, 안정하다면 자원 할당. 
아니라면 다른 프로세스가 자원을 해지할때까지 대기


경쟁 상태: 공유 자원에 프로세스가 동시에 접근할 때 결과값에 영향을 줄 수 있는 상태
e.g.) 멀티 프로세스 환경에서 공유 메모리 내의 커널 데이터에 접근할 때
    - 문제점: 멀티 프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작할 때
    - 해결책: 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock 하는 방식
    
페이징&세그먼테이션 기법 쓰는 이유: 다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억 장치를 동적분할하는 메모리 관리작업 필요
고정크기: 페이징
가변크기: 세그먼테이션

가상 메모리 페이징: 단순 페이징과 비교하여 프로세스 페이지 전부를 로드할 필요 없음, 외부 단편화 X
복잡한 메모리 관리로 오버헤드 발생

페이지 교체 알고리즘: 새로운 페이지 할당해야할 때 현재 할당된 페이지 중 어느 것을 교체할지 정하는 방식
victim page: out 되는 페이지
FIFO 알고리즘: 가장 먼저들어온게 가장 먼저 나간다
LRU(Least Recently Used) 알고리즘: 최근에 사용되지 않은 페이지가 나간다.

프로세스 스케줄링 알고리즘
- 선점: Shortest Remaining First, Round Robin, Priority
- 비선점: Shortest Job First, First Severed First Out, Priority


메모리 할당 알고리즘
- First Fit
- Best Fit
- Worst Fit
