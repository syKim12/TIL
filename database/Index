Table의 Column을 따로 파일로 저장해 색인화 함. 해당 Table의 Record를 Full scan하지 않았음. 색인화 된 (B+ Tree 구조로) Index 파일 검색으로 검색 속도를 향상

실제 DB 관련 작업을 할 때 대부분의 속도 저하는 바로 Select문 특히 조건 검색 Where절에서 발생함. 가장 먼저 생각해 볼 수 있는 대안으로 Index를 생각할 수 있기도 하고, SQL 튜닝에서도 Index와 관련된 문제사항과 해결책이 많음.

- 목적: RDBMS에서 검색속도를 높이기 위함
    - where 절의 효율성: 인덱스가 없다면 레코드의 처음부터 끝까지 풀 테이블 스캔을 함. 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 where 절에 맞는 데이터를 빠르게 찾아낼 수 있음.
    - order by 의 효율성: order by는 부하가 많이 걸리는 작업. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가 발생. 인덱스를 이용할 경우  정렬이 이미 되어있기 때문에 자원 소모하지 않아도 됨.
    - min, max 효율적인 처리: 레코드의 시작값과 끝 값 한건씩만 가져오면 되기 때문에 다 찾는 것보다 효율적이다.
- 과정: Table을 생성하면 MYD, MYI, FRM 파일이 생성
    - MYD: 실제 데이터가 있는 파일
    - FRM: 테이블 구조가 저장되어 있는 파일
    - MYI: Index 정보가 들어가 있는 파일
    - Index를 사용하지 않는 경우 MYI 파일은 비어져있음. 인덱싱할 때 MYI 파일 생성
    - 이후 사용자가 select 쿼리로 index를 사용하는 column을 탐색 시, MYI 파일의 내용을 검색
- 단점
    - 정렬된 상태를 계속 유지시켜야하기 때문에 레코드 내 데이터가 바뀌는 부분이라면 악영향을 미친다. 이에 따라 INDEX 테이블 내의 값을 다시 정렬할 뿐만 아니라, INDEX 테이블과 원본 테이블의 데이터 수정 작업 또한 해야한다.
    - Index 생성시, .mdb 파일 크기 증가
    - 인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간 추가 필요. 인덱스는 테이블의 전체 데이터 중 10~15% 이하의 데이터를 처리하는 경우에만 효율적이다
- 관리
    - 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 계속 정렬을 해주어야하며 부하가 발생한다.
    - 부하를 최소화하기 위해 데이터 삭제라는 개념에서 인덱스를 사용하지 않는다 라는 작업으로 이를 대신함
        - INSERT: 새로운 데이터에 대한 인덱스를 추가
            - 새로운 block을 할당 받은 후, key를 옮기는 작업 수행 → 많은 양의 redo가 기록
            - index split 작업 동안, 해당 block의 key 값에 대해 DML이 블로킹되며 대기 이벤트 발생 (DML: Data Manipulation Language, 데이터를 조회하거나 검색하기 위한 명령어, select, insert, update, delete)
        - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 진행
            - table에서 data가 delete 되는 경우 data가 지워지며 다른 data 가 그 공간 사용 가능 → table의 data 수와 Index의 data 수가 다를 수 있음
        - UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스 추가 → 2배의 작업 소요
- 인덱스 생성
    
    최선은 PK로 인덱스를 거는 것. 모든 값이 같은 커럼이 인덱스 컬럼이 된다면 인덱스로서의 가치가 사라짐
    
    1. 조건절(where)에 자주 등장하는 컬럼
    2. 항상 = 으로 비교되는 컬럼
    3. 중복되는 데이터가 최소한인 컬럼
    4. order by 절에서 자주 사용되는 커럼 
    5. 조인 조건으로 자주 사용되는 컬럼
